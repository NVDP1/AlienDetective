---
title: "Documentation AlienDetective.R"
author: "Niels Vandepopuliere & Matthijs Gielen"
date: "2025-06-03"
output: 
  html_document:
    number_sections: true
    toc: true
    toc_depth: 3
    toc_float: true
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

This document explains how the script `AlienDetective.R` works and how it should be used or customized.  

# Setup environment  

The script begins by configuring the working environment  

## Parallelisation setup  

The script defines the number of cores to use when running tasks in parallel (only on **Unix-based** systems). The value must be a positive integer.  

```{r}
num_cores <- 4

if (!is.numeric(num_cores) || num_cores <= 0 || num_cores != floor(num_cores)) {
  stop("Number of cores must be a positive, natural number!")
}
```

>**Note:** This parallel setup is tested only for **Unix-based systems**. If you are on Windows, it's recommended to comment out or remove this section as it may not function properly.  

## Set CRAN mirror  

To ensure package installation works on a server, the script sets a default CRAN mirror

```{r}
options(repos = c(CRAN = "https://cloud.r-project.org"))
```

You can replace the URL above with a local CRAN mirror if needed.  

## Install required packages  

This block ensures all required packages are installed (but not loaded, the use of explicit namespaces, e.g. `raster::extract()` are preferred).  

```{r}
cat(">>> [INIT] Checking for required packages...\n")
packages <- c("rgbif", "sf", "sp", "gdistance", "geodist", "raster", "fasterize", "ggplot2", "rnaturalearth", "rnaturalearthdata", "dplyr", "spThin", "foreach", "doParallel","tidyr")
for (package in packages) {
  if(!requireNamespace(package, quietly = TRUE)) {
    install.packages(package)
  }
}
```

If an installation fails due to package incompatibility with your R version, try installing it from source:  

```{r}
install.packages(package, pkgType = "source")
```

## Load custom functions  

The script loads all custom helper functions from the file `functions.R`.  

```{r}
source("src/functions.R")
```

---  

# Input  

## Command-line arguments and defaults  

The script accepts command-line arguments to define input and output paths:  

| **Position** | **Description**                |
| ------------ | -------------------------------|
| 1            | Path to species CSV file       |
| 2            | Path to coordinates CSV file   |
| 3            | Path to rasterized world map * |
| 4            | Path to cost matrix *          |
| 5            | Path to output directory       |

>*: When these files don't exist, they will be generated by the script.  

The command-line arguments are read as follows: 

```{r}
cat(">>> [INIT] Reading input data...\n")
args <- commandArgs(trailingOnly = TRUE)
species_location_path <- args[1]
location_coordinates_path <- args[2]
rasterized_path <- args[3]
cost_matrix_path <- args[4]
output_dir <- args[5]
```

*Fallback to default paths*  
If the script is run without command-line arguments, it will use predefined local paths:  

```{r}
if (length(args) == 0) {
  species_location_path <- file.path("data", "Species_Location_NIS.csv")
  location_coordinates_path <- file.path("data", "Coordinates_NIS.csv")
  land_polygons_path <- file.path("data", "land_polygons.shp")
  rasterized_path <- file.path("data", "rasterized_land_polygons.rds")
  cost_matrix_path <- file.path("data", "cost_matrix.rds")
  output_dir <- "output"
}
```

## Reading input data  

### Species presence/absence matrix  

The script reads the presence/absence matrix from a csv file.  
If a species appears more than once, only the first occurrence is kept.  
It is possible to subselect a certain species or multiple species, if not needed, comment the lines out.  

```{r}
species_location <- read.csv(species_location_path, sep = ";")
species_location <- species_location[!duplicated(species_location[1]),]

# Subselect species
species_subset <- c("...") # Specify species to subselect here
species_location <- species_location[which(species_location$Specieslist %in% species_subset),]

```

### Location coordinates  

Load the coordinate data for each observation site (`ObservatoryID` in species-location csv) from the csv file.  

```{r}
location_coordinates <- read.csv(location_coordinates_path, sep = ";")
```

### Define GBIF fields  

Define the columns to retain from the downloaded GBIF occurrence data.  

```{r}
required_columns <- c("decimalLatitude", "decimalLongitude", "year", "month", "country")
```

# Map configuration  

The script uses two key spatial objects to define the world used for the calculations:  

- `r`: A rasterized map of the world.  
- `cost_matrix`: A matrix defining the traversable paths between raster cells, essentially representing sea travel costs.  

Both objects can be saved as `.rds` files to avoid regenerating them on every script run. The script first checks whether these files already exist at the specified locations (by default, inside the `Input` folder). If they exist, they are loaded. If not, the script generates and saved them.  

>**Note:** If any of the parameters used to generate either of these files are changed, please **delete the two existing `.rds` files** to allow the script to regenerate them with the adjusted parameters.  

## Rasterized map of the world  
This section loads a high-resolution vector map of all countries using the `ne_countries()` function from the `rnaturalearth` package. This provides detailed country shapes in the form of a spatial data frame (`sf` object). A global raster grid is then created, covering the entire Earth. The grid's resolution can be adjusted to control the size of each cell (smaller cells give finer detail).  
Next, the script overlays the raster on the vector map using the `fasterize` package. By default, `fasterize` assigns a value of `1` to land cells and leaves sea cells as `NA`. However, for the purpose of this script, the values are reversed:  

- Land = `NA` -> Non-traversable  
- Sea = `1` -> Traversable  

Additionally, the script offers flexibility to use a custom shapefile to define land areas instead of using the default `rnaturalearth` data. To do this:  

1. **Uncomment** the following line and provide the corect path to your shapefile:  
`# land_polygons <- sf::st_read(land_polygons_path)`  
2. **Comment out or remove** the following line to prevent overwriting your custom data:  
`land_polygons <- rnaturalearth::ne_countries(scale = "large", returnclass = "sf')`  

```{r}
cat(">>> [MAP] Loading world map...\n")

if(file.exists(rasterized_path)) {
  r <- readRDS(rasterized_path)
} else {
  # Read vector map as sf object
  #land_polygons <- sf::st_read(land_polygons_path)
  land_polygons <- rnaturalearth::ne_countries(scale = "large", returnclass = "sf")
  cat(">>> [MAP] Rasterizing land polygons...\n")
  # Create raster
  r <- raster::raster(raster::extent(-180, 180, -90, 90), crs = sp::CRS("+init=EPSG:4326"), resolution = 0.1)
  # Rasterize vector map using fasterize
  r <- fasterize::fasterize(land_polygons, r, field = NULL, fun = "max")
  # Set sea cells to value 1 and land cells to NA (Opposite of what fasterize outputs)
  r <- raster::calc(r, function(x) ifelse(is.na(x), 1, NA))
  saveRDS(r, rasterized_path)
  rm(land_polygons)
  cat(">>> [MAP] Rasterization done. Saved raster to \"", file.path(getwd(), rasterized_path), "\"\n")
}
```

## Cost matrix  
The cost matrix represents how easily each sea cell in the raster can be reached from its neighboring cells. This is essential for calculating the least-cost paths between 2 locations.  
If the file already exists, it is simply loaded. Otherwise, the script constructs the matrix using the `gdistance` package. This is done in two steps:  

1. **Transision matrix construction**  
The function `transition()` creates a transition object based on the rasterized map. It used a `transitionFunction`, in this case `mean`, which calculates the transition value between neighboring cells as the average of their values. Since land is `NA`, any transition involving land will be `NA`, making it impassable. The `directions = 16` parameter allows movement to adjacent and diagonal cells, enabling more realistic movement across the grid.  
2. **Geographic correction**  
The `geoCorrection()` function adjusts the transition values based on real-world distances. This step is crucial because raster cells vary in physical size depending on their latitude (the closer to the pole, the narrower the cells). Without this correction, distance estimates would be geographically distorted.  

```{r}
if (file.exists(cost_matrix_path)) {
  cat(">>> [MAP] Loading cost matrix...\n")
  cost_matrix <- readRDS(cost_matrix_path)
} else {
  cat(">>> [MAP] Generating cost matrix...\n")
  # Create a transition object for adjacent cells
  cost_matrix <- gdistance::transition(r, transitionFunction = mean, directions = 16)
  # Set infinite costs to NA to prevent travel through these cells
  cost_matrix <- gdistance::geoCorrection(cost_matrix, type = "c", scl = FALSE)
  # Save transition matrix
  saveRDS(cost_matrix, file = cost_matrix_path)
  cat(">>> [MAP] Saved cost matrix to \"", file.path(getwd(), cost_matrix_path), "\"\n")
}
```

---  

# Check input coordinates file  

Due to the map's limited resolution, certain geographical locations may be incorrectly classified as land, even though they are in the sea.  
This issue most commonly occurs near coastlines, where raster cell boundaries are more sensitive to slight positional changes.  
Additionally, points located in inland water bodies are typically marked as land in the raster. These inland points may be shifted significantly when adjusted, so users should manually verify whether to include or exclude such observations.  

The script loops each row in the `location_coordinates` data frame (read from the input coordinates csv file) and performes the following steps:  

1. Extracts the location name, its longitude and latitude values, converting them from character strings to numeric format.    
2. Uses the `is_on_land()` function to determine whether the location is on land based on the rasterized map.  
3. If the location is on land, the `move_to_sea()` function attempts to move the point to the nearest sea cell.  
4. If a valid sea coordinate is found, it replaces the original coordinates in the `location_coordinates` data frame.  

>**Note:** The functions `is_on_land()` and `move_to_sea()` are defined in `src/functions.R` and are documented in [`doc/functions.html`](functions.html). Please refer to these documents for additional details or customization options.  

```{r}
# Check if input coordinates are in sea, if not, move them to sea
cat(">>> [COORD] Checking if input coordinates are in sea ...\n")
for (i in 1:nrow(location_coordinates)) {
  loc_name <- location_coordinates$Observatory.ID[i]
  longitude <- as.numeric(gsub(",", ".", location_coordinates$Longitude[i]))
  latitude <- as.numeric(gsub(",", ".", location_coordinates$Latitude[i]))  
  cat("Checking", loc_name,": latitude", latitude, ", longitude", longitude, "\n")
  
  if (is_on_land(latitude, longitude)) {
    cat(loc_name, "is on land, searching nearest sea coordinates...\n")
    moved <- move_to_sea(latitude, longitude)
    
    if (is.null(moved)) {
      cat("No valid sea coordinates found\n")
      message(loc_name, " is on land, no valid sea coordinates found")
    } else {
      # Update df with coordinates moved point
      location_coordinates$Longitude[i] <- moved$coords[1]
      location_coordinates$Latitude[i] <- moved$coords[2]
      dist <- round((moved$dist/1000), 2)
      cat("Updated", loc_name, "to", location_coordinates$Latitude[i], ", ", location_coordinates$Longitude[i], "; moved", dist, "km.\n")
    }
  } else {
    cat(loc_name, "is already in sea\n")
  }
  cat("\n")
}
cat(">>> [DONE] All coordinates updated to nearest sea point\n")
```

---  

# Distances Calculation  

This section of the script is responsible for calculating distances between known observation locations (from the species-location input CSV) and all GBIF occurrences of each species. Two types of distances are calculated:  

- **Sea distance:** Distance over water, avoiding land cells (using the cost matrix).  
- **Geodesic distance:** The shortest path, allowing travel over land.  

## Parallelisation (optional)  

On **Unix-based** operating systems, it is possible to speed up the script by enabling parallel processing across multiple CPU cores.  
To enable this, set the `num_cores` variable at the top of the script, and initialize the cluster as follows:    

```{r}
cluster <- makeCluster(num_cores)
registerDoParallel(cluster)
```

Next, replace the standard `for` loop with `foreach`, and make sure the function ends with `return(TRUE)` to suppress printing `NULL` to the terminal or output log:  

```{r}
foreach(species = species_location[,1],
        .packages = c("dplyr", "raster", "sp", "gdistance")) %dopar% {
  
  # Actual code goes here (see steps below)  
  
  return(TRUE)
}
```

After the loop finishes, stop the cluster by placing the following line **after** the closing `}` of the `foreach` block:  

```{r}
stopCluster(cluster)
```


## Step-by-step distance calculation process 

The script loops over each species listed in the `species_location` data frame (read from the species-location input CSV) and performs a series of tasks for each species. These steps are described in detail below.  

>**Note:** The functions `is_on_land()`, `move_to_sea()` `fetch_GBIF_data()` and `calculate.distances()` are defined in `src/functions.R` and are documented in [`doc/functions.html`](functions.html). Please refer to these documents for additional details or customization options.  

### Download or load GBIF data  

The scripts checks if GBIF data for the species already exists as a CSV file in the output directory. If not, it uses the `fetch_GBIF_data()` function to download the data from GBIF and save it locally.  

```{r}
for (species in species_location[,1]) {
  species_dir <- file.path(output_dir, gsub(" ", "_", species))
  gbif_occurrences_file <- file.path(species_dir, paste0(gsub(" ", "_", species), ".csv"))
  if (file.exists(gbif_occurrences_file)) {
    cat(">>> [GBIF] Loading GBIF data for", species, "\n")
    gbif_occurrences <- read.csv(gbif_occurrences_file, header = TRUE)
  } else {
    cat(">>> [GBIF] Fetching GBIF data for", species, "\n")
    gbif_occurrences <- fetch_gbif_data(species, fields = required_columns)
    if (!is.null(gbif_occurrences)) {
      if (!dir.exists(species_dir)) {
        dir.create(species_dir, recursive = TRUE)
      }
      write.csv(gbif_occurrences, file = gbif_occurrences_file, row.names = FALSE)
    } else {
      # Skip species that have no GBIF records
      return(NULL)
    }
  }
  
  # ...
}
```

### Remove duplicate coordinates  

Different GBIF occurrences can share the same coordinate pairs (same latitude and longitude). To avoid redundant calculations, the script copies the `gbif_occurrences` data frame to a new data frame `unique_coords` that retains only unique latitude-longitude combinations.  

```{r}
for (species in species_location[,1]) {
  # ...
  
  unique_coords <- unique(gbif_occurrences[c("latitude", "longitude")])
  
  # ...
}
```

### Ensure GBIF points are in the sea  

Just as with the coordinates from the input coordinate csv file, we have to make sure that the GBIF coordinates points to a point that is considered sea by the used map. Each point in `unique_coords` is checked using `is_on_land()`. If a point is on land, `move_to_sea()` tries to find the nearest sea cell. The coordinates in `unique_coords` are updated to the coordinates of the nearest sea cell.  

```{r}
for (species in species_location[,1]) {
  # ...
  
  cat(">>> [GBIF] Ensuring GBIF occurrence coordinates are at sea\n")
  counter_moved <- 0
  counter_failed <- 0
  for (i in 1:nrow(unique_coords)) {
    if (is_on_land(unique_coords$latitude[i], unique_coords$longitude[i])) {
      moved <- move_to_sea(unique_coords$latitude[i], unique_coords$longitude[i])
      if (!is.null(moved)) {
        counter_moved <- counter_moved + 1
        unique_coords$latitude_moved[i] <-moved$coords[2]
        unique_coords$longitude_moved[i] <- moved$coords[1]
        unique_coords$dist_moved[i] <- round((moved$dist/1000), 2)
      }
      else {
        counter_failed <- counter_failed + 1
      }
    }
  }
  cat(counter_moved, "of", nrow(unique_coords), "coordinate pairs were moved to sea.\n")
  if (counter_failed != 0) {
    cat("Moving to sea failed for", counter_failed, "coordinate pairs\n")
    message("Species ", species, ": moving to sea failed for ", counter_failed, " coordinate pairs.")
  }
  
  # ...
}
```

### Calculate distances to all observation locations  

For each observation location where the species was detected, the script calculates sea and geodesic distances from all GBIF points. The results are added to `unique_coords` as two new columns per location:  

- `location_seaway`  
- `location_geodesic`  

```{r}
for (species in species_location[,1]) {
  # ...

  for (location in colnames(species_location[,-1])) {
    # Skip locations where the species hasn't been detected, determined by a read number cutoff (default 1 read).
    if (species_location[which(species_location[,1] == species), location] < 1) {
      next
    }
    
    # Get coordinates for the location of observation
    latitude <- as.numeric(gsub(",", ".", location_coordinates[which(location_coordinates$Observatory.ID == location), "Latitude"]))
    longitude <- as.numeric(gsub(",", ".", location_coordinates[which(location_coordinates$Observatory.ID == location), "Longitude"]))
    if (length(latitude) != 1 || length(longitude) != 1) {
      message("Could not retrieve coordinates for location \"", location, "\"")
      next
    }
    
    # Run the distance calculations
    cat(">>> [DIST] Calculating distances to", species, "occurrences from", location, "\n")
    result <- calculate.distances(data = unique_coords,
                                  latitude = latitude,
                                  longitude = longitude,
                                  raster_map = r,
                                  cost_matrix = cost_matrix)
    
    if (!(is.null(result$seaway) & is.null(result$geodesic))) {
      unique_coords[,paste0(location, "_seaway")] <- result$sea_distances
      unique_coords[,paste0(location, "_geodesic")] <- result$geodesic_distances
    } else {
      unique_coords[,paste0(location, "_seaway")] <- NA
      unique_coords[,paste0(location, "_geodesic")] <- NA
    }
    if (!is.null(result$error_messages)) {
      message("Errors in calculation for species: ", species, "\n")
      for (error in result$error_messages) {
        message(error)
      }
    }
  }
  
  # ...
}
```

### Merge back to original GBIF data  

The updated `unique_coords` (with moved coordinates and distances) is merged back into the original `gbif_occurrences` data frame.  

```{r}
for (species in species_location[,1]) {
  # ...
  
  # Joining gbif_occurrences df & unique_coords df together
  gbif_occurrences <- gbif_occurrences %>%
    dplyr::left_join(unique_coords, by = c("latitude", "longitude"))
  
  # ...
}
```

### Save final output  

The final data frame is written to a CSV file named after the species. The output file is saved in the corresponding species folder under the `Output/` directory.  

```{r}
for (species in species_location[,1]) {
  # ...

  # Save to csv file
  write.csv(gbif_occurrences, file = gbif_occurrences_file, row.names = FALSE)
  cat("\n")
}
```

# Plotting of the species  

## Loading in the packages  

First thing is loading in the necessary packages that are used to make plots.  

```{r cars}
library("ggplot2")
library(tidyr)
library(dplyr)
```

## Actual processing the output data after writing the csv  

The output (csv file) after the distance calculations is used to make the graphs.
First graph = 

```{r}
#Iterate over species names in the species_location variable
for (species in species_location[,1]) {
  species_ <- gsub(" ", "_", species) #Change the space to a "_" to make sure the species file is found
  species_dir <- file.path(output_dir, species_) #Put the species filename in a variable
  #If the file exist execute following lines
  if (file.exists(file.path(species_dir, paste0(species_, ".csv")))) {
    #Read the species csv
    distance_df <- read.csv(file.path(species_dir, paste0(species_, ".csv")))
    #Change the format to a long format with pivot function
    long_df <- distance_df %>%
      pivot_longer(
        cols = ends_with("_seaway") | ends_with("_geodesic"), #Select all columns with _seaway and _geodesic
        names_to = "location", #Change name of original columns (cols) to location column
        values_to = "x" #Put values (distances) in a column called x
      )%>%
      separate(location, into = c("location", "DistanceType"), sep = "_") #separate the location column into location where the location represents a ARMS location and the DistanceType the type of distance
    long_sea <- long_df %>%
      filter(grepl("seaway", DistanceType)) #Put all data of seaway into a dataframe
    long_geo <- long_df %>%
      filter(grepl("geodesic", DistanceType)) #Put all data of geodesic into dataframe
    
  } else {
    warning("No output directory found for species \"", species, "\". Skipping plotting.")
    next
  }
  
  # Assign year categories
  year_categories <- c("1965-1985", "1985-1990", "1990-1995",
                       "1995-2000", "2000-2005", "2005-2010",
                       "2010-2015", "2015-2020", "2020-2025")
  long_sea$year_category <- sapply(long_sea$year, assign_year_category)
  long_geo$year_category <- sapply(long_sea$year, assign_year_category)
  
  # clean dataframe from rows with Inf and NA in them
  long_sea <- long_sea %>%
  filter(!is.na(x), is.finite(x))
  
  #Make a graph of all locations where that species is found
  country_final_plot <- country.final(
    species = species,
    distances = long_sea$x,
    output_dir = species_dir)
  
  #Make a for loop that goes over every occurence location to make seperate graphs
  for (loc in unique(long_sea$location)) {
    sea_loc_data <- long_sea[long_sea$location == loc, ] #filter data on that specific location
    geo_loc_data <- long_geo[long_geo$location == loc, ]
    
    # Plot functions by location
    plot_dist_sea <- plot.dist.sea(
      species = species,
      location = loc,
      distances = sea_loc_data$x,
      output_dir = species_dir
    )
    
    plot_both <- plot.dist.both(
      species = species,
      location = loc,
      distances = combined_distances$x,
      output_dir = species_dir
    )
    
    plot_country <- plot.dist.by.country(
      species = species,
      location = loc,
      distances = sea_loc_data$x,
      output_dir = species_dir
    )
    
    plot_year <- plot.dist.by.year(
      species = species,
      location = loc,
      distances = sea_loc_data$x,
      output_dir = species_dir
    )
  }
}

```
## Filtering data on location
This script collects all the different species found at one ARMS location from several CSV files created after distance calculations. It combines them into one new CSV file. This file will then be used to make a single graph that shows how the species behave, starting from the ARMS location where they were found.
```{r pressure, echo=FALSE}
# Put all ARMS locations from the Coordinates_NIS.csv file into variable
search_locations <- unique(location_coordinates$Observatory.ID)

# Set the main folder path
main_folder <- "data/Output_M"
species_folders <- list.dirs(path = main_folder, full.names = TRUE, recursive = FALSE)
filtered_data_list <- list()
```
## Processing
Create loop structure that goes over every csv folder after distances calculations. Read the data, change to the right format and search for the specific ARMS location in the location column.Store all data that has that specific location into one data frame. 
```{r}
# Loop through each species folder
for (folder in species_folders) {
  csv_files <- list.files(path = folder, pattern = "\\.csv$", full.names = TRUE)
  
  for (csv_file in csv_files) {
    data <- read.csv(csv_file, stringsAsFactors = FALSE)
    
    long_df <- data %>%
      pivot_longer(
        cols = ends_with("_seaway") | ends_with("_geodesic"),
        names_to = "location",
        values_to = "x"
      ) %>%
      separate(location, into = c("location", "DistanceType"), sep = "_")
    
    long_sea <- long_df %>%
      filter(grepl("seaway", DistanceType)) %>%
      filter(!is.na(x))
    
    # Filter only for locations listed in Coordinates_NIS.csv
    filtered_rows <- long_sea %>%
      filter(location %in% search_locations)
    
    if (nrow(filtered_rows) > 0) {
      filtered_rows$Species <- basename(folder)
      filtered_data_list[[length(filtered_data_list) + 1]] <- filtered_rows
    }
  }
}
```
### Create output directory
Combine all data frames so you can loop over each unique ARMS locations.
```{r}
# Combine all filtered data
all_filtered_data <- bind_rows(filtered_data_list)

# Continue with your plotting logic...
locations <- unique(all_filtered_data$location) #Get all unique locations (ARMS) into variable
location_graphs_folder <- file.path(main_folder, "Location_graphs") # Create folder
if (!dir.exists(location_graphs_folder)) {
  dir.create(location_graphs_folder)
}
```

## Plotting part
A plot is made for every ARMS location where the distribution is showed from that location to different locations in GBIF. Every species is colored in a different color to see which pattern the species shows from that ARMS location.
```{r}
# Loop over every ARMS location
for (loc in locations) {
  safe_loc <- gsub("[^a-zA-Z0-9_-]", "_", loc) #Clear out the name so every location has the same format
  location_folder <- file.path(location_graphs_folder, safe_loc) # Create output folder
  if (!dir.exists(location_folder)) {
    dir.create(location_folder, recursive = TRUE)
  }
  
  loc_data <- subset(all_filtered_data, location == loc) # Get location out of filtered data
  loc_data <- loc_data[complete.cases(loc_data$x) & is.finite(loc_data$x), ] # Remove NA and Inf values
  
  csv_file_path <- file.path(location_folder, paste0("filtered_", safe_loc, ".csv")) # Create path to make csv folder
  write.csv(loc_data, csv_file_path, row.names = FALSE)
  # Creating plot
  plot <- ggplot(loc_data, aes(x = x, fill = Species)) +
    geom_histogram(aes(y = after_stat(count / sum(count) * 100)),
                   binwidth = 50,
                   boundary = 0,
                   position = "stack") +
    labs(title = paste0("Distribution of different species that are present in ", loc),
         x = "Sea distance (km)", y = "Percentage of total counts (%)") +
    theme_bw() +
    theme(
      plot.title = element_text(hjust = 0.5, size = 15, face = "bold"),
      plot.margin = margin(0.3, 0.3, 0.4, 0.4, "cm"),
      axis.text = element_text(size = 10),
      axis.title = element_text(size = 12),
      legend.title = element_text(size = 10),
      legend.text = element_text(size = 8),
      legend.key.size = unit(1, "lines"),
      axis.text.x = element_text(angle = 45, hjust = 1)
    ) +
    scale_x_continuous(breaks = seq(0, 8000, by = 500), expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    coord_cartesian(xlim = c(0, 8000), ylim = c(0, 20))
  
  plot_file_path <- file.path(location_folder, paste0("Distribution_of_species_in_", safe_loc, ".png"))
  ggsave(filename = plot_file_path, plot = plot, width = 2400, height = 1200, units = "px", dpi = 300)
}
plot
```
>**Note:** The custom functions used to create the plots are defined in `src/functions.R` and documented in [doc/functions.html](functions.html). Please refer to these documents for additional information.  

